---
title: プロバイダー
description: OpenCode で LLM プロバイダーを使用する。
---

import config from "../../../../config.mjs"
export const console = config.console

OpenCode は [AI SDK](https://ai-sdk.dev/) および [Models.dev](https://models.dev) を使用して **75 以上の LLM プロバイダー** をサポートし、ローカルモデルの実行をサポートします。

プロバイダーを追加するには、次のことを行う必要があります。

1. `/connect` コマンドを使用して、プロバイダーの API キーを追加します。
2. OpenCode 設定でプロバイダーを構成します。

---

### 認証情報

`/connect` コマンドを使用してプロバイダーの API キーを追加すると、それらは保存されます
`~/.local/share/opencode/auth.json`で。

---

### 設定

OpenCode の `provider` セクションを通じてプロバイダーをカスタマイズできます。
config.

---

#### Base URL

`baseURL` オプションを設定することで、任意のプロバイダーのベース URL をカスタマイズできます。これは、プロキシサービスまたはカスタムエンドポイントを使用する場合に便利です。

```json title="opencode.json" {6}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "anthropic": {
      "options": {
        "baseURL": "https://api.anthropic.com/v1"
      }
    }
  }
}
```

---

## OpenCode Zen

OpenCode Zen は、OpenCode チームが提供するモデルのリストです。
OpenCode で適切に動作することがテストおよび検証されています。 [詳細はこちら](/docs/zen)。

:::tip
初めての方は、OpenCode Zen から始めることをお勧めします。
:::

1. TUI で `/connect` コマンドを実行し、opencode を選択して、[opencode.ai/auth](https://opencode.ai/auth) で認証します。

   ```txt
   /connect
   ```

2. サインインし、お支払いの詳細を追加し、API キーをコピーします。

3. API キーを貼り付けます。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. TUI で `/models` を実行すると、推奨されるモデルのリストが表示されます。

   ```txt
   /models
   ```

これは OpenCode の他のプロバイダーと同様に機能し、使用は完全にオプションです。

---

## ディレクトリ

いくつかのプロバイダーを詳しく見てみましょう。プロバイダーを追加したい場合は、
リストにある場合は、お気軽に PR を開いてください。

:::note
ここにプロバイダーが表示されない場合は、 PRを送信してください。
:::

---

### 302.AI

1. [302.AI console](https://302.ai/) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**302.AI** を検索します。

   ```txt
   /connect
   ```

3. 302.AI API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

---

### Amazon Bedrock

OpenCode で Amazon Bedrock を使用するには:

1. Amazon Bedrock コンソールの **モデルカタログ** に移動してリクエストします。
   必要なモデルにアクセスします。

:::tip
Amazon Bedrock で必要なモデルにアクセスできる必要があります。
:::

2. **次のいずれかの方法を使用して認証を構成します**。

   #### 環境変数 (クイックスタート)

opencode の実行中に次の環境変数のいずれかを設定します。

```bash
   # Option 1: Using AWS access keys
   AWS_ACCESS_KEY_ID=XXX AWS_SECRET_ACCESS_KEY=YYY opencode

   # Option 2: Using named AWS profile
   AWS_PROFILE=my-profile opencode

   # Option 3: Using Bedrock bearer token
   AWS_BEARER_TOKEN_BEDROCK=XXX opencode
```

または、それらを bash プロファイルに追加します。

```bash title="~/.bash_profile"
   export AWS_PROFILE=my-dev-profile
   export AWS_REGION=us-east-1
```

#### 設定ファイル (推奨)

プロジェクト固有の設定または永続的な設定の場合は、`opencode.json` を使用します。

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "amazon-bedrock": {
      "options": {
        "region": "us-east-1",
        "profile": "my-aws-profile"
      }
    }
  }
}
```

**利用可能なオプション:**

- `region` - AWS リージョン (例: `us-east-1`、`eu-west-1`)
- `profile` - `~/.aws/credentials` からの AWS 名前付きプロファイル
- `endpoint` - VPC エンドポイントのカスタムエンドポイント URL (汎用 `baseURL` オプションのエイリアス)

:::tip
設定ファイルのオプションは環境変数より優先されます。
:::

#### 上級: VPC エンドポイント

Bedrock の VPC エンドポイントを使用している場合:

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "amazon-bedrock": {
      "options": {
        "region": "us-east-1",
        "profile": "production",
        "endpoint": "https://bedrock-runtime.us-east-1.vpce-xxxxx.amazonaws.com"
      }
    }
  }
}
```

:::note
`endpoint` オプションは、AWS 固有の用語を使用した汎用の `baseURL` オプションのエイリアスです。 `endpoint` と `baseURL` の両方が指定された場合は、`endpoint` が優先されます。
:::

#### 認証方法

- **`AWS_ACCESS_KEY_ID` / `AWS_SECRET_ACCESS_KEY`**: IAM ユーザーを作成し、AWS コンソールでアクセスキーを生成します。
- **`AWS_PROFILE`**: `~/.aws/credentials` の名前付きプロファイルを使用します。最初に `aws configure --profile my-profile` または `aws sso login` を設定します
- **`AWS_BEARER_TOKEN_BEDROCK`**: Amazon Bedrock コンソールから長期 API キーを生成します
- **`AWS_WEB_IDENTITY_TOKEN_FILE` / `AWS_ROLE_ARN`**: EKS IRSA (サービスアカウントの IAM ロール) または OIDC フェデレーションを備えた他の Kubernetes 環境の場合。これらの環境変数は、サービスアカウントアノテーションを使用するときに Kubernetes によって自動的に挿入されます。

#### 認証の優先順位

Amazon Bedrock は次の認証優先度を使用します。

1.  **ベアラー トークン** - `AWS_BEARER_TOKEN_BEDROCK` 環境変数または `/connect` コマンドからのトークン
2.  **AWS 認証情報チェーン** - プロファイル、アクセスキー、共有認証情報、IAM ロール、Web ID トークン (EKS IRSA)、インスタンスメタデータ

:::note
ベアラー トークンが (`/connect` または `AWS_BEARER_TOKEN_BEDROCK` 経由で) 設定されると、設定されたプロファイルを含むすべての AWS 認証情報方法よりも優先されます。
:::

3. `/models` コマンドを実行して、必要なモデルを選択します。

   ```txt
   /models
   ```

:::note
カスタム推論プロファイルの場合、キーでモデルとプロバイダー名を使用し、`id` プロパティを arn に設定します。これにより、正しいキャッシュが保証されます。

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "amazon-bedrock": {
      // ...
      "models": {
        "anthropic-claude-sonnet-4.5": {
          "id": "arn:aws:bedrock:us-east-1:xxx:application-inference-profile/yyy"
        }
      }
    }
  }
}
```

:::

---

### Anthropic

1. サインアップしたら、`/connect` コマンドを実行し、[Anthropic] を選択します。

   ```txt
   /connect
   ```

2. ここで **Claude Pro/Max** オプションを選択すると、ブラウザが開きます
   そして認証を求められます。

   ```txt
   ┌ Select auth method
   │
   │ Claude Pro/Max
   │ Create an API Key
   │ Manually enter API Key
   └
   ```

3. これで、`/models` コマンドを使用すると、すべての Anthropic モデルが利用できるようになります。

   ```txt
   /models
   ```

:::info
OpenCode での Claude Pro/Max サブスクリプションの使用は、[Anthropic](https://anthropic.com) によって正式に許可されていませんが、一般的に機能します。
:::

##### APIキーの使用

Pro/Max サブスクリプションをお持ちでない場合は、[**API キーの作成**] を選択することもできます。また、ブラウザが開き、Anthropic にログインするよう求められ、ターミナルに貼り付けるコードが表示されます。

または、すでに API キーをお持ちの場合は、[**API キーを手動で入力**] を選択してターミナルに貼り付けることができます。

---

### Azure OpenAI

:::note
「申し訳ありませんが、そのリクエストには対応できません」エラーが発生した場合は、Azure リソースのコンテンツフィルターを **DefaultV2** から **Default** に変更してみてください。
:::

1. [Azure portal](https://portal.azure.com/) に移動し、**Azure OpenAI** リソースを作成します。必要なものは次のとおりです。
   - **リソース名**: これは API エンドポイント (`https://RESOURCE_NAME.openai.azure.com/`) の一部になります。
   - **API キー**: リソースの `KEY 1` または `KEY 2` のいずれか

2. [Azure AI Foundry](https://ai.azure.com/) に移動し、モデルをデプロイします。

:::note
OpenCode が正しく動作するには、デプロイメント名がモデル名と一致する必要があります。
:::

3. `/connect` コマンドを実行し、**Azure** を検索します。

   ```txt
   /connect
   ```

4. API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

5. リソース名を環境変数として設定します。

   ```bash
   AZURE_RESOURCE_NAME=XXX opencode
   ```

または、bash プロファイルに追加します。

```bash title="~/.bash_profile"
   export AZURE_RESOURCE_NAME=XXX
```

6. `/models` コマンドを実行して、デプロイされたモデルを選択します。

   ```txt
   /models
   ```

---

### Azure Cognitive Services

1. [Azure portal](https://portal.azure.com/) に移動し、**Azure OpenAI** リソースを作成します。必要なものは次のとおりです。
   - **リソース名**: これは API エンドポイント (`https://AZURE_COGNITIVE_SERVICES_RESOURCE_NAME.cognitiveservices.azure.com/`) の一部になります。
   - **API キー**: リソースの `KEY 1` または `KEY 2` のいずれか

2. [Azure AI Foundry](https://ai.azure.com/) に移動し、モデルをデプロイします。

:::note
OpenCode が正しく動作するには、デプロイメント名がモデル名と一致する必要があります。
:::

3. `/connect` コマンドを実行し、**Azure Cognitive Services** を検索します。

   ```txt
   /connect
   ```

4. API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

5. リソース名を環境変数として設定します。

   ```bash
   AZURE_COGNITIVE_SERVICES_RESOURCE_NAME=XXX opencode
   ```

または、bash プロファイルに追加します。

```bash title="~/.bash_profile"
   export AZURE_COGNITIVE_SERVICES_RESOURCE_NAME=XXX
```

6. `/models` コマンドを実行して、デプロイされたモデルを選択します。

   ```txt
   /models
   ```

---

### Baseten

1. [Baseten](https://app.baseten.co/) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**Baseten** を検索します。

   ```txt
   /connect
   ```

3. Baseten API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

---

### Cerebras

1. [Cerebras console](https://inference.cerebras.ai/) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**Cerebras** を検索します。

   ```txt
   /connect
   ```

3. Cerebras API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Qwen 3 Coder 480B_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Cloudflare AI Gateway

Cloudflare AI Gatewayを使用すると、統合エンドポイントを通じてOpenAI、Anthropic、Workers AIなどのモデルにアクセスできます。 [Unified Billing](https://developers.cloudflare.com/ai-gateway/features/unified-billing/) を使用すると、プロバイダーごとに個別の API キーは必要ありません。

1. [Cloudflare ダッシュボード ](https://dash.cloudflare.com/) に移動し、**AI** > **AI ゲートウェイ** に移動し、新しいゲートウェイを作成します。

2. アカウント ID とゲートウェイ ID を環境変数として設定します。

   ```bash title="~/.bash_profile"
   export CLOUDFLARE_ACCOUNT_ID=your-32-character-account-id
   export CLOUDFLARE_GATEWAY_ID=your-gateway-id
   ```

3. `/connect` コマンドを実行し、**Cloudflare AI Gateway** を検索します。

   ```txt
   /connect
   ```

4. Cloudflare API トークンを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

または環境変数として設定します。

```bash title="~/.bash_profile"
   export CLOUDFLARE_API_TOKEN=your-api-token
```

5. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

OpenCode 設定を通じてモデルを追加することもできます。

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "cloudflare-ai-gateway": {
      "models": {
        "openai/gpt-4o": {},
        "anthropic/claude-sonnet-4": {}
      }
    }
  }
}
```

---

### Cortecs

1. [Cortecs console](https://cortecs.ai/) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**Cortecs** を検索します。

   ```txt
   /connect
   ```

3. Cortecs API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Kimi K2 Instruct_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### DeepSeek

1. [DeepSeek コンソール ](https://platform.deepseek.com/) に移動し、アカウントを作成し、**新しい API キーの作成** をクリックします。

2. `/connect` コマンドを実行し、**DeepSeek** を検索します。

   ```txt
   /connect
   ```

3. DeepSeek API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_DeepSeek Reasoner_ のような DeepSeek モデルを選択します。

   ```txt
   /models
   ```

---

### Deep Infra

1. [Deep Infra ダッシュボード](https://deepinfra.com/dash) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**Deep Infra** を検索します。

   ```txt
   /connect
   ```

3. Deep Infra API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

---

### Firmware

1. [ファームウェアダッシュボード](https://app.firmware.ai/signup) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**ファームウェア**を検索します。

   ```txt
   /connect
   ```

3. ファームウェア API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

---

### Fireworks AI

1. [Fireworks AI コンソール ](https://app.fireworks.ai/) に移動し、アカウントを作成し、**API キーの作成** をクリックします。

2. `/connect` コマンドを実行し、**Fireworks AI** を検索します。

   ```txt
   /connect
   ```

3. Fireworks AI API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Kimi K2 Instruct_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### GitLab Duo

GitLab Duo は、GitLab の Anthropic プロキシを介したネイティブツール呼び出し機能を備えた AI を活用したエージェントチャットを提供します。

1. `/connect` コマンドを実行し、GitLab を選択します。

   ```txt
   /connect
   ```

2. 認証方法を選択してください:

   ```txt
   ┌ Select auth method
   │
   │ OAuth (Recommended)
   │ Personal Access Token
   └
   ```

   #### OAuthの使用(推奨)

**OAuth** を選択すると、認証のためにブラウザが開きます。

#### パーソナルアクセストークンの使用

1.  [GitLab ユーザー設定 > アクセス Tokens](https://gitlab.com/-/user_settings/personal_access_tokens) に移動します。
2.  **新しいトークンを追加** をクリックします
3.  名前: `OpenCode`、スコープ: `api`
4.  トークンをコピーします（`glpat-`で始まる）
5.  ターミナルに入力してください

6.  `/models` コマンドを実行して、利用可能なモデルを確認します。

    ```txt
    /models
    ```

3 つの Claude ベースのモデルが利用可能です。

- **duo-chat-haiku-4-5** (デフォルト) - 素早いタスクに対する素早い応答
- **duo-chat-sonnet-4-5** - ほとんどのワークフローでバランスの取れたパフォーマンス
- **duo-chat-opus-4-5** - 複雑な分析に最も適した能力

:::note
必要がない場合は、「GITLAB_TOKEN」環境変数を指定することもできます。
トークンを OpenCode 認証ストレージに保存します。
:::

##### 自己ホスト型 GitLab

:::note[コンプライアンスメモ]
OpenCode は、セッションタイトルの生成などの一部の AI タスクに小規模なモデルを使用します。
デフォルトでは、Zen によってホストされる gpt-5-nano を使用するように構成されています。 OpenCode をロックするには
自分の GitLab でホストされているインスタンスのみを使用するには、次の行を
`opencode.json` ファイル。セッション共有を無効にすることもお勧めします。

```json
{
  "small_model": "gitlab/duo-chat-haiku-4-5",
  "share": "disabled"
}
```

:::

セルフホスト型 GitLab インスタンスの場合:

```bash
export GITLAB_INSTANCE_URL=https://gitlab.company.com
export GITLAB_TOKEN=glpat-...
```

インスタンスがカスタム AI ゲートウェイを実行している場合:

```bash
GITLAB_AI_GATEWAY_URL=https://ai-gateway.company.com
```

または、bash プロファイルに追加します。

```bash title="~/.bash_profile"
export GITLAB_INSTANCE_URL=https://gitlab.company.com
export GITLAB_AI_GATEWAY_URL=https://ai-gateway.company.com
export GITLAB_TOKEN=glpat-...
```

:::note
GitLab 管理者は以下を有効にする必要があります。

1. [Duo Agent Platform](https://docs.gitlab.com/user/gitlab_duo/turn_on_off/) (ユーザー、グループ、またはインスタンス用)
2. 機能フラグ (Rails コンソール経由):
   - `agent_platform_claude_code`
   - `third_party_agents_enabled`
     :::

##### セルフホスト型インスタンスの OAuth

自己ホスト型インスタンスで Oauth を機能させるには、以下を作成する必要があります。
新しいアプリケーション ([設定] → [アプリケーション]) で、
コールバック URL `http://127.0.0.1:8080/callback` と次のスコープ:

- api (あなたの代わりに API にアクセスします)
- read_user (個人情報の読み取り)
- read_repository (リポジトリへの読み取り専用アクセスを許可します)

次に、アプリケーション ID を環境変数として公開します。

```bash
export GITLAB_OAUTH_CLIENT_ID=your_application_id_here
```

詳細については、[opencode-gitlab-auth](https://www.npmjs.com/package/@gitlab/opencode-gitlab-auth) ホームページ。

##### 設定

`opencode.json` を通じてカスタマイズします。

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "gitlab": {
      "options": {
        "instanceUrl": "https://gitlab.com",
        "featureFlags": {
          "duo_agent_platform_agentic_chat": true,
          "duo_agent_platform": true
        }
      }
    }
  }
}
```

##### GitLab API ツール (オプションですが強く推奨)

GitLab ツール (マージリクエスト、問題、パイプライン、CI/CD など) にアクセスするには:

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "plugin": ["@gitlab/opencode-gitlab-plugin"]
}
```

このプラグインは、MR レビュー、問題追跡、パイプライン監視などを含む、包括的な GitLab リポジトリ管理機能を提供します。

---

### GitHub Copilot

GitHub Copilot サブスクリプションを OpenCode で使用するには:

:::note
一部のモデルでは [Pro+] が必要になる場合があります。
subscription](https://github.com/features/copilot/plans) を使用します。

一部のモデルは、[GitHub Copilot settings](https://docs.github.com/en/copilot/how-tos/use-ai-models/configure-access-to-ai-models#setup-for-individual-use) で構成する必要があります。
:::

1. `/connect` コマンドを実行し、GitHub Copilot を検索します。

   ```txt
   /connect
   ```

2. [github.com/login/device](https://github.com/login/device) に移動し、コードを入力します。

   ```txt
   ┌ Login with GitHub Copilot
   │
   │ https://github.com/login/device
   │
   │ Enter code: 8F43-6FCF
   │
   │
   └ Waiting for authorization...
   ```

3. 次に、`/models` コマンドを実行して、必要なモデルを選択します。

   ```txt
   /models
   ```

---

### Google Vertex AI

OpenCode で Google Vertex AI を使用するには:

1. Google Cloud Console の **Model Garden** に移動し、
   お住まいの地域で利用可能なモデル。

:::note
Vertex AI API が有効になっている Google Cloud プロジェクトが必要です。
:::

2. 必要な環境変数を設定します。
   - `GOOGLE_CLOUD_PROJECT`: Google Cloud プロジェクト ID
   - `VERTEX_LOCATION` (オプション): Vertex AI の領域 (デフォルトは `global`)
   - 認証 (1 つ選択):
     - `GOOGLE_APPLICATION_CREDENTIALS`: サービスアカウントの JSON キーファイルへのパス
     - gcloud CLI を使用して認証する: `gcloud auth application-default login`

opencode の実行中に設定します。

```bash
   GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json GOOGLE_CLOUD_PROJECT=your-project-id opencode
```

または、それらを bash プロファイルに追加します。

```bash title="~/.bash_profile"
   export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
   export GOOGLE_CLOUD_PROJECT=your-project-id
   export VERTEX_LOCATION=global
```

:::tip
`global` 領域は、追加コストなしで可用性を向上させ、エラーを削減します。データ常駐要件には、リージョンエンドポイント (`us-central1` など) を使用します。 [詳細はこちら](https://cloud.google.com/vertex-ai/generative-ai/docs/partner-models/use-partner-models#regional_and_global_endpoints)
:::

3. `/models` コマンドを実行して、必要なモデルを選択します。

   ```txt
   /models
   ```

---

### Groq

1. [Groq console](https://console.groq.com/) に移動し、[**API キーの作成**] をクリックして、キーをコピーします。

2. `/connect` コマンドを実行し、Groq を検索します。

   ```txt
   /connect
   ```

3. プロバイダーの API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、必要なものを選択します。

   ```txt
   /models
   ```

---

### Hugging Face

[Hugging Face Inference Provider](https://huggingface.co/docs/inference-providers) は、17 を超えるプロバイダーがサポートするオープンモデルへのアクセスを提供します。

1. [Hugging Face settings](https://huggingface.co/settings/tokens/new?ownUserPermissions=inference.serverless.write&tokenType=fineGrained) に移動して、推論プロバイダーを呼び出す権限を持つトークンを作成します。

2. `/connect` コマンドを実行し、**Hugging Face** を検索します。

   ```txt
   /connect
   ```

3. Hugging Face トークンを入力してください。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Kimi-K2-Instruct_ や _GLM-4.6_ などのモデルを選択します。

   ```txt
   /models
   ```

---

### Helicone

[Helicone](https://helicone.ai) は、AI アプリケーションのロギング、監視、分析を提供する LLM 可観測性プラットフォームです。 Helicone AI ゲートウェイは、モデルに基づいてリクエストを適切なプロバイダーに自動的にルーティングします。

1. [Helicone](https://helicone.ai) に移動し、アカウントを作成し、ダッシュボードから API キーを生成します。

2. `/connect` コマンドを実行し、**Helicone** を検索します。

   ```txt
   /connect
   ```

3. Helicone API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

その他のプロバイダーや、キャッシュやレート制限などの高度な機能については、[Helicone ドキュメント](https://docs.helicone.ai).

#### オプションの設定

OpenCode を通じて自動的に構成されていない Helicone の機能またはモデルを見つけた場合は、いつでも自分で構成できます。

これは [Helicone のモデルディレクトリ](https://helicone.ai/models) です。追加するモデルの ID を取得するためにこれが必要になります。

```jsonc title="~/.config/opencode/opencode.jsonc"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "helicone": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "Helicone",
      "options": {
        "baseURL": "https://ai-gateway.helicone.ai",
      },
      "models": {
        "gpt-4o": {
          // Model ID (from Helicone's model directory page)
          "name": "GPT-4o", // Your own custom name for the model
        },
        "claude-sonnet-4-20250929": {
          "name": "Claude Sonnet 4",
        },
      },
    },
  },
}
```

#### カスタムヘッダー

Helicone は、キャッシュ、ユーザー追跡、セッション管理などの機能のカスタムヘッダーをサポートしています。 `options.headers` を使用してプロバイダー設定に追加します。

```jsonc title="~/.config/opencode/opencode.jsonc"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "helicone": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "Helicone",
      "options": {
        "baseURL": "https://ai-gateway.helicone.ai",
        "headers": {
          "Helicone-Cache-Enabled": "true",
          "Helicone-User-Id": "opencode",
        },
      },
    },
  },
}
```

##### セッション追跡

Helicone の [Sessions](https://docs.helicone.ai/features/sessions) 機能を使用すると、関連する LLM リクエストをグループ化できます。 [opencode-helicone-session](https://github.com/H2Shami/opencode-helicone-session) プラグインを使用して、各 OpenCode 会話を Helicone のセッションとして自動的に記録します。

```bash
npm install -g opencode-helicone-session
```

それを設定に追加します。

```json title="opencode.json"
{
  "plugin": ["opencode-helicone-session"]
}
```

プラグインは、リクエストに `Helicone-Session-Id` ヘッダーと `Helicone-Session-Name` ヘッダーを挿入します。 Helicone のセッションページでは、OpenCode の各会話が個別のセッションとしてリストされています。

##### 一般的なヘリコーンヘッダー

| ヘッダー                   | 説明                                                                   |
| -------------------------- | ---------------------------------------------------------------------- |
| `Helicone-Cache-Enabled`   | 応答キャッシュを有効にする (`true`/`false`)                            |
| `Helicone-User-Id`         | ユーザーごとにメトリクスを追跡する                                     |
| `Helicone-Property-[Name]` | カスタムプロパティを追加します (例: `Helicone-Property-Environment`)。 |
| `Helicone-Prompt-Id`       | リクエストをプロンプトバージョンに関連付ける                           |

利用可能なすべてのヘッダーについては、[Helicone Header Directory](https://docs.helicone.ai/helicone-headers/header-directory) を参照してください。

---

### llama.cpp

[llama.cpp の s](https://github.com/ggml-org/llama.cpp) llama-server ユーティリティ] を通じて、ローカルモデルを使用するように opencode を構成できます。

```json title="opencode.json" "llama.cpp" {5, 6, 8, 10-15}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "llama.cpp": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "llama-server (local)",
      "options": {
        "baseURL": "http://127.0.0.1:8080/v1"
      },
      "models": {
        "qwen3-coder:a3b": {
          "name": "Qwen3-Coder: a3b-30b (local)",
          "limit": {
            "context": 128000,
            "output": 65536
          }
        }
      }
    }
  }
}
```

この例では:

- `llama.cpp` はカスタムプロバイダー ID です。これには任意の文字列を指定できます。
- `npm` は、このプロバイダーに使用するパッケージを指定します。ここで、`@ai-sdk/openai-compatible` は OpenAI 互換 API に使用されます。
- `name` は、UI でのプロバイダーの表示名です。
- `options.baseURL` はローカルサーバーのエンドポイントです。
- `models` は、モデル ID とその設定のマップです。機種選択リストに機種名が表示されます。

---

### IO.NET

IO.NET は、さまざまなユースケースに最適化された 17 のモデルを提供します。

1. [IO.NET console](https://ai.io.net/) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**IO.NET** を検索します。

   ```txt
   /connect
   ```

3. IO.NET API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

---

### LM Studio

LM Studio を通じてローカルモデルを使用するように opencode を構成できます。

```json title="opencode.json" "lmstudio" {5, 6, 8, 10-14}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "lmstudio": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "LM Studio (local)",
      "options": {
        "baseURL": "http://127.0.0.1:1234/v1"
      },
      "models": {
        "google/gemma-3n-e4b": {
          "name": "Gemma 3n-e4b (local)"
        }
      }
    }
  }
}
```

この例では:

- `lmstudio` はカスタムプロバイダー ID です。これには任意の文字列を指定できます。
- `npm` は、このプロバイダーに使用するパッケージを指定します。ここで、`@ai-sdk/openai-compatible` は OpenAI 互換 API に使用されます。
- `name` は、UI でのプロバイダーの表示名です。
- `options.baseURL` はローカルサーバーのエンドポイントです。
- `models` は、モデル ID とその設定のマップです。機種選択リストに機種名が表示されます。

---

### Moonshot AI

Moonshot AI の Kim K2 を使用するには:

1. [Moonshot AI console](https://platform.moonshot.ai/console) に移動し、アカウントを作成し、[**API キーの作成**] をクリックします。

2. `/connect` コマンドを実行し、**Moonshot AI** を検索します。

   ```txt
   /connect
   ```

3. Moonshot API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Kimi K2_ を選択します。

   ```txt
   /models
   ```

---

### MiniMax

1. [MiniMax API Console](https://platform.minimax.io/login) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**MiniMax** を検索します。

   ```txt
   /connect
   ```

3. MiniMax API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_M2.1_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Nebius Token Factory

1. [Nebius Token Factory console](https://tokenfactory.nebius.com/) に移動し、アカウントを作成し、[**キーの追加**] をクリックします。

2. `/connect` コマンドを実行し、**Nebius Token Factory** を検索します。

   ```txt
   /connect
   ```

3. Nebius Token Factory API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Kimi K2 Instruct_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Ollama

Ollama を通じてローカルモデルを使用するように opencode を構成できます。

:::tip
Ollama は OpenCode 用に自動的に構成できます。詳細については、[Ollama 統合 docs](https://docs.ollama.com/integrations/opencode)」を参照してください。
:::

```json title="opencode.json" "ollama" {5, 6, 8, 10-14}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "ollama": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "Ollama (local)",
      "options": {
        "baseURL": "http://localhost:11434/v1"
      },
      "models": {
        "llama2": {
          "name": "Llama 2"
        }
      }
    }
  }
}
```

この例では:

- `ollama` はカスタムプロバイダー ID です。これには任意の文字列を指定できます。
- `npm` は、このプロバイダーに使用するパッケージを指定します。ここで、`@ai-sdk/openai-compatible` は OpenAI 互換 API に使用されます。
- `name` は、UI でのプロバイダーの表示名です。
- `options.baseURL` はローカルサーバーのエンドポイントです。
- `models` は、モデル ID とその設定のマップです。機種選択リストに機種名が表示されます。

:::tip
ツール呼び出しが機能しない場合は、Ollama の `num_ctx` を増やしてみてください。 16k〜32kあたりから始めてください。
:::

---

### Ollama Cloud

OpenCode で Ollama Cloud を使用するには:

1. [https://ollama.com/](https://ollama.com/) にアクセスしてサインインするか、アカウントを作成します。

2. [**設定**] > [キー**] に移動し、[**API キーの追加**] をクリックして新しい API キーを生成します。

3. OpenCode で使用するために API キーをコピーします。

4. `/connect` コマンドを実行し、**Ollama Cloud** を検索します。

   ```txt
   /connect
   ```

5. Ollama Cloud API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

6. **重要**: OpenCode でクラウドモデルを使用する前に、モデル情報をローカルに取得する必要があります。

   ```bash
   ollama pull gpt-oss:20b-cloud
   ```

7. `/models` コマンドを実行して、Ollama Cloud モデルを選択します。

   ```txt
   /models
   ```

---

### OpenAI

[ChatGPT Plus または Pro](https://chatgpt.com/pricing) にサインアップすることをお勧めします。

1. サインアップしたら、`/connect` コマンドを実行し、OpenAI を選択します。

   ```txt
   /connect
   ```

2. ここで **ChatGPT Plus/Pro** オプションを選択すると、ブラウザが開きます。
   そして認証を求められます。

   ```txt
   ┌ Select auth method
   │
   │ ChatGPT Plus/Pro
   │ Manually enter API Key
   └
   ```

3. これで、`/models` コマンドを使用すると、すべての OpenAI モデルが利用できるようになります。

   ```txt
   /models
   ```

##### APIキーの使用

すでに API キーをお持ちの場合は、**API キーを手動で入力** を選択し、ターミナルに貼り付けることができます。

---

### OpenCode Zen

OpenCode Zen は、OpenCode チームによって提供される、テストおよび検証されたモデルのリストです。 [詳細はこちら](/docs/zen)。

1. **<a href={console}>OpenCode Zen</a>** にサインインし、**API キーの作成** をクリックします。

2. `/connect` コマンドを実行し、**OpenCode Zen** を検索します。

   ```txt
   /connect
   ```

3. OpenCode API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Qwen 3 Coder 480B_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### OpenRouter

1. [OpenRouter ダッシュボード](https://openrouter.ai/settings/keys) に移動し、[**API キーの作成**] をクリックして、キーをコピーします。

2. `/connect` コマンドを実行し、OpenRouter を検索します。

   ```txt
   /connect
   ```

3. プロバイダーの API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. 多くの OpenRouter モデルはデフォルトでプリロードされており、`/models` コマンドを実行して必要なモデルを選択します。

   ```txt
   /models
   ```

OpenCode 設定を通じて追加のモデルを追加することもできます。

```json title="opencode.json" {6}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "openrouter": {
      "models": {
        "somecoolnewmodel": {}
      }
    }
  }
}
```

5. OpenCode 設定を通じてカスタマイズすることもできます。プロバイダーを指定する例を次に示します。

   ```json title="opencode.json"
   {
     "$schema": "https://opencode.ai/config.json",
     "provider": {
       "openrouter": {
         "models": {
           "moonshotai/kimi-k2": {
             "options": {
               "provider": {
                 "order": ["baseten"],
                 "allow_fallbacks": false
               }
             }
           }
         }
       }
     }
   }
   ```

---

### SAP AI Core

SAP AI コアは、統合プラットフォームを通じて、OpenAI、Anthropic、Google、Amazon、Meta、Mistral、AI21 の 40 以上のモデルへのアクセスを提供します。

1. [SAP BTP Cockpit](https://account.hana.ondemand.com/) に移動し、SAP AI コアサービスインスタンスに移動して、サービスキーを作成します。

:::tip
サービスキーは、`clientid`、`clientsecret`、`url`、および `serviceurls.AI_API_URL` を含む JSON オブジェクトです。 AI コアインスタンスは、BTP コックピットの **サービス** > **インスタンスとサブスクリプション** で見つかります。
:::

2. `/connect` コマンドを実行し、**SAP AI Core** を検索します。

   ```txt
   /connect
   ```

3. サービスキーの JSON を入力します。

   ```txt
   ┌ Service key
   │
   │
   └ enter
   ```

または、`AICORE_SERVICE_KEY` 環境変数を設定します。

```bash
   AICORE_SERVICE_KEY='{"clientid":"...","clientsecret":"...","url":"...","serviceurls":{"AI_API_URL":"..."}}' opencode
```

または、bash プロファイルに追加します。

```bash title="~/.bash_profile"
   export AICORE_SERVICE_KEY='{"clientid":"...","clientsecret":"...","url":"...","serviceurls":{"AI_API_URL":"..."}}'
```

4. 必要に応じて、デプロイメント ID とリソースグループを設定します。

   ```bash
   AICORE_DEPLOYMENT_ID=your-deployment-id AICORE_RESOURCE_GROUP=your-resource-group opencode
   ```

:::note
これらの設定はオプションであり、SAP AI コアのセットアップに従って構成する必要があります。
:::

5. `/models` コマンドを実行して、40 以上の利用可能なモデルから選択します。

   ```txt
   /models
   ```

---

### OVHcloud AI Endpoints

1. [OVHcloud パネル](https://ovh.com/manager) に移動します。 `Public Cloud` セクション、`AI & Machine Learning` > `AI Endpoints` に移動し、`API Keys` タブで **新しい API キーの作成** をクリックします。

2. `/connect` コマンドを実行し、**OVHcloud AI エンドポイント**を検索します。

   ```txt
   /connect
   ```

3. OVHcloud AI エンドポイント API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_gpt-oss-120b_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Scaleway

[Scaleway Generative APIs](https://www.scaleway.com/en/docs/generative-apis/) を Opencode で使用するには:

1. [Scaleway Console IAM settings](https://console.scaleway.com/iam/api-keys) に移動して、新しい API キーを生成します。

2. `/connect` コマンドを実行し、**Scaleway** を検索します。

   ```txt
   /connect
   ```

3. Scaleway API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_devstral-2-123b-instruct-2512_ や _gpt-oss-120b_ などのモデルを選択します。

   ```txt
   /models
   ```

---

### Together AI

1. [Together AI console](https://api.together.ai) に移動し、アカウントを作成し、[**キーの追加**] をクリックします。

2. `/connect` コマンドを実行し、**Together AI** を検索します。

   ```txt
   /connect
   ```

3. Together AI API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Kimi K2 Instruct_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Venice AI

1. [Venice AI console](https://venice.ai) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**Venice AI** を検索します。

   ```txt
   /connect
   ```

3. Venice AI API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Llama 3.3 70B_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Vercel AI Gateway

Vercel AI Gateway を使用すると、統合エンドポイントを通じて OpenAI、Anthropic、Google、xAI などのモデルにアクセスできます。モデルは値上げなしの定価で提供されます。

1. [Vercel ダッシュボード ](https://vercel.com/) に移動し、**AI ゲートウェイ** タブに移動し、**API キー** をクリックして新しい API キーを作成します。

2. `/connect` コマンドを実行し、**Vercel AI Gateway** を検索します。

   ```txt
   /connect
   ```

3. Vercel AI Gateway API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行してモデルを選択します。

   ```txt
   /models
   ```

OpenCode 設定を通じてモデルをカスタマイズすることもできます。プロバイダーのルーティング順序を指定する例を次に示します。

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "vercel": {
      "models": {
        "anthropic/claude-sonnet-4": {
          "options": {
            "order": ["anthropic", "vertex"]
          }
        }
      }
    }
  }
}
```

いくつかの便利なルーティングオプション:

| オプション          | 説明                                                 |
| ------------------- | ---------------------------------------------------- |
| `order`             | 試行するプロバイダーシーケンス                       |
| `only`              | 特定のプロバイダーに制限する                         |
| `zeroDataRetention` | データ保持ポリシーがゼロのプロバイダーのみを使用する |

---

### xAI

1. [xAI console](https://console.x.ai/) に移動し、アカウントを作成し、API キーを生成します。

2. `/connect` コマンドを実行し、**xAI** を検索します。

   ```txt
   /connect
   ```

3. xAI API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_Grok Beta_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### Z.AI

1. [Z.AI API コンソール ](https://z.ai/manage-apikey/apikey-list) に移動し、アカウントを作成し、**新しい API キーの作成** をクリックします。

2. `/connect` コマンドを実行し、**Z.AI** を検索します。

   ```txt
   /connect
   ```

**GLM コーディングプラン**に加入している場合は、**Z.AI コーディングプラン**を選択します。

3. Z.AI API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. `/models` コマンドを実行して、_GLM-4.7_ のようなモデルを選択します。

   ```txt
   /models
   ```

---

### ZenMux

1. [ZenMux ダッシュボード](https://zenmux.ai/settings/keys) に移動し、[**API キーの作成**] をクリックして、キーをコピーします。

2. `/connect` コマンドを実行し、ZenMux を検索します。

   ```txt
   /connect
   ```

3. プロバイダーの API キーを入力します。

   ```txt
   ┌ API key
   │
   │
   └ enter
   ```

4. 多くの ZenMux モデルはデフォルトでプリロードされており、`/models` コマンドを実行して必要なモデルを選択します。

   ```txt
   /models
   ```

OpenCode 設定を通じて追加のモデルを追加することもできます。

```json title="opencode.json" {6}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "zenmux": {
      "models": {
        "somecoolnewmodel": {}
      }
    }
  }
}
```

---

## カスタムプロバイダー

`/connect` コマンドにリストされていない **OpenAI 互換**プロバイダーを追加するには:

:::tip
OpenAI と互換性のある任意のプロバイダーを OpenCode で使用できます。最新の AI プロバイダーのほとんどは、OpenAI 互換の API を提供しています。
:::

1. `/connect` コマンドを実行し、**その他**まで下にスクロールします。

   ```bash
   $ /connect

   ┌  Add credential
   │
   ◆  Select provider
   │  ...
   │  ● Other
   └
   ```

2. プロバイダーの一意の ID を入力します。

   ```bash
   $ /connect

   ┌  Add credential
   │
   ◇  Enter provider id
   │  myprovider
   └
   ```

:::note
覚えやすい ID を選択してください。これを設定ファイルで使用します。
:::

3. プロバイダーの API キーを入力します。

   ```bash
   $ /connect

   ┌  Add credential
   │
   ▲  This only stores a credential for myprovider - you will need to configure it in opencode.json, check the docs for examples.
   │
   ◇  Enter your API key
   │  sk-...
   └
   ```

4. プロジェクトディレクトリで `opencode.json` ファイルを作成または更新します。

   ```json title="opencode.json" ""myprovider"" {5-15}
   {
     "$schema": "https://opencode.ai/config.json",
     "provider": {
       "myprovider": {
         "npm": "@ai-sdk/openai-compatible",
         "name": "My AI ProviderDisplay Name",
         "options": {
           "baseURL": "https://api.myprovider.com/v1"
         },
         "models": {
           "my-model-name": {
             "name": "My Model Display Name"
           }
         }
       }
     }
   }
   ```

構成オプションは次のとおりです。

- **npm**: 使用する AI SDK パッケージ、OpenAI 互換プロバイダーの場合は `@ai-sdk/openai-compatible`
- **name**: UI での表示名。
- **models**: 利用可能なモデル。
- **options.baseURL**: API エンドポイント URL。
- **options.apiKey**: 認証を使用しない場合は、オプションで API キーを設定します。
- **options.headers**: 必要に応じてカスタムヘッダーを設定します。

詳細オプションの詳細については、以下の例を参照してください。

5. `/models` コマンドを実行すると、カスタムプロバイダーとモデルが選択リストに表示されます。

---

##### 例

次に、`apiKey`、`headers`、およびモデル `limit` オプションを設定する例を示します。

```json title="opencode.json" {9,11,17-20}
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "myprovider": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "My AI ProviderDisplay Name",
      "options": {
        "baseURL": "https://api.myprovider.com/v1",
        "apiKey": "{env:ANTHROPIC_API_KEY}",
        "headers": {
          "Authorization": "Bearer custom-token"
        }
      },
      "models": {
        "my-model-name": {
          "name": "My Model Display Name",
          "limit": {
            "context": 200000,
            "output": 65536
          }
        }
      }
    }
  }
}
```

設定の詳細:

- **apiKey**: `env` 変数構文を使用して設定します。[詳細については ](/docs/config#env-vars).
- **headers**: 各リクエストとともに送信されるカスタムヘッダー。
- **limit.context**: モデルが受け入れる最大入力トークン。
- **limit.output**: モデルが生成できる最大出力トークン。

`limit` フィールドを使用すると、OpenCode はコンテキストがどのくらい残っているかを理解できます。標準プロバイダーは、これらを models.dev から自動的に取得します。

---

## トラブルシューティング

プロバイダーの設定で問題が発生した場合は、次の点を確認してください。

1. **認証設定を確認します**: `opencode auth list` を実行して、資格情報が正しいかどうかを確認します。
   プロバイダー用のものが設定に追加されます。

これは、認証に環境変数に依存する Amazon Bedrock のようなプロバイダーには当てはまりません。

2. カスタムプロバイダーの場合は、OpenCode 設定を確認し、次のことを行います。
   - `/connect` コマンドで使用されるプロバイダー ID が、OpenCode 設定内の ID と一致することを確認してください。
   - プロバイダーには適切な npm パッケージが使用されます。たとえば、Cerebras には `@ai-sdk/cerebras` を使用します。他のすべての OpenAI 互換プロバイダーの場合は、`@ai-sdk/openai-compatible` を使用します。
   - `options.baseURL` フィールドで正しい API エンドポイントが使用されていることを確認してください。
